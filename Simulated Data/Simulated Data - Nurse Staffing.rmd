---
title: "Simulated Data: Nurse Staffing and Quality of Care"
author: "Nikhil Haas"
date: "May 13, 2015"
output: pdf_document
---

# Introduction

This simulated data set is based on the journal article "Is More Better? The
Relationship between Nurse Staffing and the Quality of Nursing Care in
Hospitals" in Medical Care (Sochalski, 2004). In this study, Sochalski
analyzed data obtained from a 1999 survey of 8,670 inpatient nurses from
Pennsylvania, U.S.A. hospitals. The survey asked nurses to rate the
quality of care they delivered to patients during their last shift and estimate
the number of patients they cared for, the number of tasks that went undone, and
the number of patient safety problems that occurred during the same shift. The
author found several correlations between the responses to the questions. The
questions and response data from survey are the inspiration for this simulated
data set. 

# Method

Here, we generate artificial responses to the questions that were in the 1999
survey. In this simulated scenario, the responses are entered into a mock
hospital administrative database over several years by its nurses in an effort
to better understand what the hospital can do to improve patient care. The
hospital has no knowledge of what factors correlate with patient care and is
hoping to use the data obtained to discover relationships that will help them
achieve their goal of delivering better care.

The relationships discovered by Sochalski will drive the correlations between
survey responses in this simulated data set. However, to attempt to represent
the difficulties and variabilities in analyzing such a data set in the real
world, staffing ratios during weekdays and the weekend will be unequal and both
noise and confounding factors will be introduced into the data.

## Questions and Response Ranges

Nurses have been asked to complete the survey following each shift. Below are
the columns of data that will hold the response data, as well as the expected
ranges for each response type.

1. Employee ID: Between 0 and 9000
2. Quality of care as rated by nurses: Poor, Fair, Good, Excellent
3. Number of registered nurses on-staff during last shift: 1 - 30
4. Number of patients cared for during last shift: 0 - 20
5. Number of tasks that went undone during last shift: 0 - 7
6. Number of patient safety problems during last shift: 0 - 4
7. Date this survey was taken: YYYY/MM/DD

## Code

A single function, `generateDataSet()`, will be used to create the simulated data
set. This function shall take two inputs, a `startDate` and an `endDate`,
and generates survey responses for numerous ficticious employees for each day
between those two dates. `generateDataSet()` will run several sub-functions that
perform the various logical steps in generating the data. These sub-functions
are:

* `genDaysfromRange`: generate a table of dates between `startDate` and
  `endDate` to make data for
* `expandRows`: for each date, make a row to hold a survey response for each
  nurse who worked that day
* `setQualOfCareRating`: create a Quality of Care rating for each survey
  response
* `relateQualOfCareToNumPatients`: create each nurse's Patient Workload
* `addEmployeeID`: create employee IDs for each survey response
* `convertQual`: convert Quality of Care from integers to strings 'Poor',
  'Fair', etc.
* `filterCols`: remove the tempoary columns that were use during data generation

With these sub-functions, we can then define a single function to generate and
return the data set:

```{r gen_data, eval=FALSE}
generateDataSet <- function(startDate, endDate) {
  eachDay <- genDaysFromRange(startDate, endDate)  
  dataSet <- expandRows(eachDay)
  dataSet <- setQualOfCareRating(dataSet)
  dataSet <- relateQualOfCareToNumPatients(dataSet)
  dataSet <- addEmployeeID(dataSet)
  dataSet <- convertQual(dataSet)
  dataSet <- filterCols(dataSet)
  )
  dataSet
}
```

Then run the function:

```{r run_generate_data, eval=FALSE}
dataSet <- generateDataSet(startDate="1998/03/08", endDate="2007/12/01")
```

The full code can be seen in Appendix A.

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=2)
set.seed(43)
```

```{r set_constraints, echo=FALSE}
# Set constraints
qualOfCareOptions <- c("Poor", "Fair", "Good", "Excellent")
qualOfCareProb <- list(weekday=c(.02, .04, .30, .64),
                       weekend=c(.4, .33, .21, .06))
numNurses <- c(weekday=c(mean=11, sd=1.2),
               weekend=c(mean=6, sd=1))

numTasksUndone <- c(0:7)
numTasksUndoneMean <- c(weekday=1.9, weekend=4.1)
numSafetyProbs <- c(0:4)
numSafetyProbsMean <- c(weekday=0.4, weekend=1.1)

startDate="1998/03/08"
endDate="2007/12/01"
```

```{r gen_days, echo=FALSE}
genDaysFromRange <- function(startDate, endDate) {
  # This function creates a data frame where each row represents a day
  # (starting from 'startDate' and ending on 'endDate') containing the day
  # of the week, whether or not the day is a weekday or a weekend day, and
  # the number of nurses working that day. Using the value for number of
  # nurses that worked each day, later we will create a data frame to
  # represent each nurse's daily responses to the questions asked by the
  # survey, which we will ultimately return as the final data set.
  #
  # |    date    | dayOfWeek | typeOfDay | numNurses |
  # | 1998/03/08 |   Sunday  |  weekend  |     7     |
  # | 1998/03/09 |   Monday  |  weekday  |     9     |
  #                        etc...
  
  # Create column of dates
  eachDay <- data.frame(date=seq.Date(as.Date(startDate),
                                      as.Date(endDate), 
                                      by='day'))
  # Create column identifying each date as 'Sunday', 'Monday', etc.
  eachDay$dayOfWeek <- weekdays(as.Date(eachDay$date))
  # Create column that identifies each day as 'weekday' or 'weekend', using
  # the value in the 'dayOfWeek' column to lookup whether or not the day is a
  # 'weekday' or 'weekend' day.
  typeOfDay <- c(Sunday='weekend',
                 Monday='weekday',
                 Tuesday='weekday',
                 Wednesday='weekday',
                 Thursday='weekday',
                 Friday='weekday',
                 Saturday='weekend')
  eachDay$typeOfDay <- typeOfDay[eachDay$dayOfWeek]
  
  # Create column containing number of nurses that worked that day, which
  # depends on whether or not the day is a 'weekday' or 'weekend' day.
  eachDay$numNurses <- NA
  for (w in c('weekday', 'weekend')) {
    # You need to get mean and STD of number of nurses using the variable
    # 'numNurses' and index it like: numNurses['weekday.mean'] or
    # numNurses['weekend.sd']. Build those index values first:
    mean <- paste(w, 'mean', sep='.')  # 'weekday.mean' or 'weekend.mean'
    sd <- paste(w, 'sd', sep='.')  # 'weekday.sd' or 'weekend.sd'
    # Pull out all 'weekday' or 'weekend' days, depending on which 'w' we
    # are on in the for loop, and add the number of nurses from a normal
    # distribution whose parameters have already been set in 'numNurses'.
    numDaysOfType <- sum(eachDay$typeOfDay == w)
    sampleNurses <- rnorm(n=numDaysOfType,
                          mean=numNurses[mean],
                          sd=numNurses[sd])
    sampleNurses <- as.integer(round(sampleNurses), digits=0)
    eachDay$numNurses[eachDay$typeOfDay == w] <- sampleNurses
    }
  eachDay
}
```

```{r expand_days, echo=FALSE}
expandRows <- function(eachDay) {
  # This function takes the data frame generated earlier (which contains
  # the number of nurses working per day) and expands those rows so there is a
  # row for *each nurse* that worked *each day*. In other words, this
  # function will expand each day in N times, where N is the numNurses
  # that worked that day. These expanded rows will contain the daily responses
  # nurses enter into the system after they finish a shift.
  
  # Repeate each row "number_of_times=numNurses", taking columns 1, 3, & 4 and
  # setting row.names to NULL:
  dataSet <- data.frame(eachDay[rep(c(1:nrow(eachDay)), eachDay$numNurses),
                                c(1, 3, 4)],
                        row.names=NULL)
  # Set column headers of the expanded data frame
  names(dataSet) <- c('date', 'typeOfDay', 'numDailyStaffedNurses')
  dataSet
}
```

```{r qual_of_care, echo=FALSE}
setQualOfCareRating <- function(dataSet) {
  # Creates a column containg Quality of Care ratings for 'weekday' and
  # 'weekend' days. Quality of Care on the weekend will generally be lower
  # because the number of nurses is lower. Quality of Care is rated by nurses
  # as Poor, Fair, Good, or Excellent, but here we will use 1-4 to represent
  # these values during data generation.
  
  dataSet$qualOfCare = NA
  for (w in c('weekday', 'weekend')) {
    rowsOfType <- dataSet$typeOfDay[dataSet$typeOfDay == w]
    qualRating <- sample(x=c(1:length(qualOfCareOptions)),
                         size=length(rowsOfType),
                         prob=as.numeric(unlist(qualOfCareProb[w])),
                         replace=T)
    dataSet$qualOfCare[dataSet$typeOfDay == w] <- qualRating
    }
  dataSet
}
```

```{r relate_qual_of_care, echo=FALSE}
relateQualOfCareToNumPatients <- function(dataSet) {
  # Creates a column 'numPatientsCaredFor' which is linearly related to
  # qualOfCare. In the paper, the relationship between the two variables is
  # argued to be in the reverse (i.e. that Quality of Care rating depends on
  # Number of Patients). This is not being refuted, here, we are simply using
  # a reverse relationship to generate the data set. The linearly relationship
  # will exist no matter which variable we have depend on which, so it is up
  # to the analyst to interpret the direction of the relationship.
  
  linRelate <- function(x) {
    # The linear relationship to be applied to qualOfCare
    -1.76*x + 9 + rpois(1, lambda=2)
    # Adds some variability using Poisson distribution. With lambda=2, the
    # distribution should have mode=1, min=0, max=8, mean=2. The idea is that
    # on a given day a nurse could get overloaded by caring for more patients,
    # but the likelihood of getting overloaded by N patients decreases as N
    # increases.
    # Visualize: http://www.umass.edu/wsp/resources/poisson/
    }
  
  dataSet$patientWorkload <- NA
  for (w in c('weekday', 'weekend')) {
    rowsOfType <- dataSet$qualOfCare[dataSet$typeOfDay == w]
    dataSet$patientWorkload[dataSet$typeOfDay == w] <- vapply(
      rowsOfType,
      FUN=linRelate,
      FUN.VALUE=double(1)
      )
    }
  # Set the Patient Workload as an integer instead of a decimal value
  dataSet$patientWorkload <- as.integer(
    round(dataSet$patientWorkload, digits=0)
    )
  dataSet
}
```

```{r employee_id, echo=FALSE}
addEmployeeID <- function(dataSet){
    # Adds a column of employee IDs, where on the weekend certain employees are
    # more likely to work.
    
    # Number of employees should be greater than their maximum daily staff
    ids <- runif(max(dataSet$numDailyStaffedNurses) + 15, 0, 9000)
    ids <- paste0('00', as.integer(ids))  # Add 00s before ID for realism
    
    dataSet$employeeID <- NA
    
    # For every day, need to get a sample of employee IDs
    for (d in unique(dataSet$date)) {
      dailyResponses <- subset(dataSet, date == d)
      numResponses <- nrow(dailyResponses)
      typeOfDay <- dailyResponses$typeOfDay[1]
      
      # Sample the employee IDs using a custom probability distrubition on
      # the IDs. This makes some employees more likely to work the weekends, and
      # other employees never work the weekends:
      p <- rep(0, length(ids))
      p[1:2] <- 0.22
      p[3] <- 0.01
      p[4:6] <- 0.12
      p[7:9] <- 0.05
      p[10:11] <- 0.02
      if (typeOfDay == 'weekend') {
        idsList <- sample(x=ids,
                          size=numResponses,
                          replace=F,
                          prob=p)
      } else {
        # Otherwise, if it's a weekday get a random employee ID
        idsList <- sample(x=ids,
                          size=numResponses,
                          replace=F)
      }
      dataSet$employeeID[dataSet$date == d] <- idsList
    }
    dataSet
  }
```

```{r convert_qual, echo=FALSE}
convertQual <- function(dataSet) {
  # Convert Quality of Care to "Poor", "Fair", etc.
  dataSet$qualOfCare <- cut(as.numeric(dataSet$qualOfCare), 4, c("Poor",
                                                                 "Fair",
                                                                 "Good",
                                                                 "Excellent"))
  dataSet
}
```

```{r filter_cols, echo=FALSE}
filterCols <- function(dataSet) {
  # Return the dataSet without typeOfDay
  data.frame(subset(dataSet, select=(c("date",
                                       "employeeID",
                                       "qualOfCare",
                                       "patientWorkload",
                                       "numDailyStaffedNurses"))))
}
```

# Results

By creating the `eachDay` data frame, we have a list of days and the number of
nurses that worked every day. The *numNurses* working each day is generated from
a random normal distribution that is different for weekday and weekend days.
The effects of that difference can be seen in Table 1, which shows that only 7
nurses worked the first Sunday, compared to a typical 9-12 nurses during the
weekdays.

```{r, echo=FALSE}
eachDay <- genDaysFromRange(startDate, endDate)
```
```{r print_days_table, echo=FALSE, eval=TRUE}
# Output the head of the eachDay table
# Source 'knitr' to use kable function later for pretty tables
options(warn=-1); suppressMessages(library(knitr)); options(warn=0)
kable(head(eachDay),
      row.names=F,
      caption="Head of `eachDay` data.frame from genDaysFromRange()")
```

This difference can be seen across the entire dataset in Table 2.

```{r days_stats, echo=FALSE, comment=NA}
# Print some stats about the dates data
e <- data.frame(c(round(mean(eachDay$numNurses), digits=2),
                  round(mean(eachDay$numNurses[eachDay$typeOfDay == 'weekday'], digits=2)),
                  round(mean(eachDay$numNurses[eachDay$typeOfDay == 'weekend'], digits=2)),
                  round(min(eachDay$numNurses[eachDay$typeOfDay == 'weekday']), digits=0),
                  round(min(eachDay$numNurses[eachDay$typeOfDay == 'weekend']), digits=0),
                  round(max(eachDay$numNurses[eachDay$typeOfDay == 'weekday']), digits=0),
                  round(max(eachDay$numNurses[eachDay$typeOfDay == 'weekend']), digits=0)),
                row.names=c("Mean number of nurses",
                            "Mean number of nurses (weekday)",
                            "Mean number of nurses (weekend)",
                            "Min number of nurses (weekday)",
                            "Min number of nurses (weekend)",
                            "Max number of nurses (weekday)",
                            "Max number of nurses (weekend)"))
names(e) <- c("Value")
kable(e, caption="Means, Min. and Max. Values from `eachDay`")
```

```{r echo=FALSE}
dataSet <- expandRows(eachDay)
dataSet <- setQualOfCareRating(dataSet)
```
```{r qual_of_care_stats, echo=FALSE}
# Output quality of care stats
for (w in c('weekday', 'weekend')) {
  print(sprintf("Mean quality of care during %s: %.2f",
                w,
                mean(dataSet$qualOfCare[dataSet$typeOfDay == w])))
  print(sprintf("SD for quality of care during %s: %.2f",
                w,
                sd(dataSet$qualOfCare[dataSet$typeOfDay == w])))
}
```
```{r qual_of_care_hist1, echo=FALSE, fig.width=3.5, fig.height=3}
for (w in c('weekday', 'weekend')) {
  simpleCap <- function(x) {
    s <- strsplit(x, " ")[[1]]
    paste(toupper(substring(s, 1, 1)), substring(s, 2), sep = "",
          collapse = " ")
    }
  hist_title <- paste(simpleCap(w), "Quality of Care",
                      collapse=" ")
  hist(dataSet$qualOfCare[dataSet$typeOfDay == w],
       main=hist_title,
       xlab="Quality of Care Rating")
}
```
```{r, echo=FALSE}
dataSet <- relateQualOfCareToNumPatients(dataSet)
dataSet <- addEmployeeID(dataSet)
```
```{r employee_id_hist, echo=FALSE, fig.width=3.5, fig.height=3}
# Output histogram of working employees
hist(as.integer(dataSet$employeeID[dataSet$typeOfDay == 'weekday']),
     main='Weekday Employees',
     xlab='Employee ID')
hist(as.integer(dataSet$employeeID[dataSet$typeOfDay == 'weekend']),
     main='Weekend Employees',
     xlab='Employee ID')
```
```{r, echo=FALSE}
dataSet <- convertQual(dataSet)
dataSet <- filterCols(dataSet)
```
```{r dataset_stats, echo=FALSE}
# Output the head of the dataSet
kable(head(dataSet),
      row.names=F,
      caption="Head of final dataSet")
```

# References

Sochalski, J. (2004). Is more better?: the relationship between nurse staffing
and the quality of nursing care in hospitals. Medical care, 42(2), II-67.


```{r filter_cols, eval=FALSE}